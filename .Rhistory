cluster.avgs['Adm3',]
cluster.avgs['Adm2',]
cluster.avgs['Adm1',]
cluster.avgs['Adm',]
cluster.avgs['Lep',]
cluster.avgs['Vldl',]
cluster.avgs['SCarb',]
cluster.avgs['Scarb',]
cluster.avgs$Imm
hmp <- c('A2m','Adam9','Adam12')
which(rownames(cluster.avgs) == hmp)
rownames(cluster.avgs)
rownames(cluster.avgs) == hmp
which(rownames(cluster.avgs) == hmp)
?which
sum(rownames(cluster.avgs))
sum(rownames(cluster.avgs)==hmp)
sum(rownames(cluster.avgs)[rownames(cluster.avgs)])
rownames(cluster.avgs)[rownames(cluster.avgs)]
rownames(cluster.avgs)[hmp]
hmp
rownameS(cluster.avgs)
rownames(cluster.avgs)
load("~/Box Sync/Kaminski_Lab/ipf.Robj")
FeaturePlot(ipf,'AGTR2')
FeaturePlot(ipf,'AGTR2',reduction = 'tsne')
FeaturePlot(ipf,'AGTR2',reduction = 'tsne',label = T)
VlnPlot(ipf,'AGTR2',label = T)
load("~/Box Sync/Kaminski_Lab/control.Robj")
VlnPlot(control,'AGTR2',label = T)
VlnPlot(ipf,'AGTR1',label = T)
VlnPlot(control,'AGTR1',label = T)
VlnPlot(ipf,'AGTR1',label = T)
VlnPlot(control,'AGTR1',label = T)
FeaturePlot(ipf,'AGTR1')
FeaturePlot(ipf,'AGTR1',label= T)
FeaturePlot(ipf,'AGTR1',label= T,reduction = 'tsne')
FeaturePlot(control,'AGTR1',label= T,reduction = 'tsne')
require(roxygen2)
require(devtools)
setwd("~/Documents/GitHub/connectome")
document()
install_github('msraredon/connectome', ref = 'master',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
library(connectome)
setwd("~/Documents/GitHub/connectome")
nodes <- as.character(unique(union(df$source,df$target)))
load("~/Box Sync/BEF/Lung Data/BEF14/scRNAseq/BEF14.Robj")
load("~/Box Sync/BEF/Lung Data/BEF15/scRNAseq/BEF15.Robj")
require(Seurat)
BEF14 <- ScaleData(BEF14,features = rownames(BEF14))
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = T,calculate.DOR = F)
test <- FilterConnectome(BEF14.con,min.z = 0,min.pct = 0.1,modes.include = 'TGFB')
connectome <- test
cols.use = NULL
library(tidyverse)
library(circlize)
library(dplyr)
library(scales)
library(ComplexHeatmap)
weight.attribute = 'weight_sc'
min.z = NULL
lab.cex = 1
balanced.edges = T
edge.color.by.source = T
library(tidyverse)
library(circlize)
library(dplyr)
library(scales)
library(ComplexHeatmap)
# Perform filtration
#if (weight.attribute != 'source'){
if (weight.attribute == 'weight_sc' & is.null(min.z)){
connectome <- FilterConnectome(connectome, remove.na = T,min.z = 0,...)
}else{
connectome <- FilterConnectome(connectome,remove.na = T,min.z = min.z,...)
}
#}
# Pull the dataframe of interest for plotting and format with weight as third column
connectome$lig.stash <- as.character(connectome$ligand)
#}
# Pull the dataframe of interest for plotting and format with weight as third column
connectome$lig.stash <- as.character(connectome$ligand)
connectome$rec.stash <- as.character(connectome$receptor)
df <- data.frame(connectome %>% select(ligand,receptor))
df$ligand <- make.unique(as.character(df$ligand))
df$receptor <- make.unique(as.character(df$receptor))
#df$weight <- connectome[,weight.attribute]
temp <- connectome[,!colnames(connectome) %in% colnames(df)]
df <- cbind(df,temp)
# Squash ligands back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(df$lig.stash)){
temp <- subset(df,lig.stash == df$lig.stash[i])
for (i in 1:length(unique(temp$source))){
temp2 <- subset(temp,source == unique(temp$source)[i])
dummy <- paste(rep(' ',i-1),collapse = '') # Add number of spaces corresponding to number of unique sources
df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
}
#if(length(unique(temp$source)) == 1){
#  df[rownames(temp),]$ligand <- as.character(temp$lig.stash)
#}
}
# Squash receptors back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(df$rec.stash)){
temp <- subset(df,rec.stash == df$rec.stash[i])
for (i in 1:length(unique(temp$target))){
temp2 <- subset(temp,target == unique(temp$target)[i])
dummy <- paste(rep(' ',i-1),collapse = '') # Add number of spaces corresponding to number of unique targets
df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
}
#if(length(unique(temp$target)) == 1){
#  df[rownames(temp),]$receptor <- as.character(temp$rec.stash)
#}
}
#Establish ordering (order) so that genes are grouped nicely by celltype
source.order <- df[order(df$source), ]
target.order <- df[order(df$target), ]
source.order.un <- unique(source.order[,c('ligand','source')])
target.order.un <- unique(target.order[,c('receptor','target')])
source.order$id <- 1:nrow(source.order)
target.order$id <- 1:nrow(target.order)
source.order.un$id <- 1:nrow(source.order.un)
target.order.un$id <- 1:nrow(target.order.un)
sector.order.un <- c(as.character(source.order.un$ligand),
as.character(target.order.un$receptor))
# Coloring setup
if (is.null(cols.use)){
nodes <- as.character(unique(union(df$source,df$target)))
cols.use <- hue_pal()(length(nodes))
names(cols.use) <- nodes
cols.use <- data.frame(cols.use)
cols.use$cell <- rownames(cols.use)
}
cols.use
cols.use <- NULL
nodes <- as.character(unique(union(df$source,df$target)))
cols.use <- hue_pal()(length(nodes))
names(cols.use) <- nodes
cols.use
class(cols.use)
cols.use
cols.use <- data.frame(cols.use)
cols.use
cols.use$cell <- rownames(cols.use)
cols.use
require(roxygen2)
require(devtools)
setwd("~/Documents/GitHub/connectome")
document()
setwd("~/Documents/GitHub/connectome")
document()
setwd("~/Documents/GitHub/connectome")
document()
setwd("~/Documents/GitHub/connectome")
document()
install_github('msraredon/connectome', ref = 'develop',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
install_github('msraredon/connectome', ref = 'develop',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
library(connectome)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = T,calculate.DOR = F)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = T,calculate.DOR = F)
install_github('msraredon/connectome', ref = 'develop',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
library(connectome)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = T,calculate.DOR = F)
require(connectome)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = T,calculate.DOR = F)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = F,calculate.DOR = T)
View(BEF14.con)
setwd("~/Documents/GitHub/connectome")
document()
install_github('msraredon/connectome', ref = 'develop',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
require(roxygen2)
require(devtools)
setwd("~/Documents/GitHub/connectome")
document()
setwd("~/Documents/GitHub/connectome")
document()
install_github('msraredon/connectome', ref = 'develop',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
library(connectome)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = F,calculate.DOR = F)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = T,calculate.DOR = F)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = F,calculate.DOR = T)
View(BEF14.con)
install_github('msraredon/connectome', ref = 'master',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
library(connectome)
require(Seurat)
require(connectome)
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = F,calculate.DOR = F)
con1 <- BEF14.con
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = T,calculate.DOR = F)
con2 <- BEF14.con
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = F,calculate.DOR = T)
con3 <- BEF14.con
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = T,calculate.DOR = T)
con4 <- BEF14.con
sum(con1$recept.expression == con2$recept.expression)
?sum
sum(con1$recept.expression == con2$recept.expression,na.rm = T)
View(con1)
View(con2)
View(con3)
View(con4)
FeaturePlot(BEF14,'Il4r')
connectome::DOR
connectome:::DOR
LR.database = 'fantom5'
species = NULL
include.putative = T
include.rejected = F
p.values = T
max.cells.per.ident = NULL
weight.definition.norm = 'product'
weight.definition.scale = 'mean'
custom.list = NULL
calculate.DOR = F
object
object <- BEF14
library(Seurat)
library(dplyr)
library(tibble)
library(plotrix)
species <- 'rat'
if (LR.database == 'fantom5' & is.null(species)){stop("\nPlease select species for fantom5 mapping. Allows 'human','mouse','rat', or 'pig' ")}
# Downsample input object
if (!is.null(max.cells.per.ident)){
object <- Seurat::SubsetData(object = object,max.cells.per.ident = max.cells.per.ident)
#object <- subset(object, cells = WhichCells(object, downsample = max.cells.per.ident))
}
if (LR.database == 'fantom5'){
# Load ground-truth database (FANTOM5, species-converted as appropriate, per methodlogy in Raredon et al 2019, DOI: 10.1126/sciadv.aaw3851)
if (species == 'human'){
fantom5 <- ncomms8866_human
}
if (species == 'mouse'){
fantom5 <- ncomms8866_mouse
}
if (species == 'rat'){
fantom5 <- ncomms8866_rat
}
if (species == 'pig'){
fantom5 <- ncomms8866_pig
}
# Import ligand-receptor pairs and metadata
lit.put <- fantom5[fantom5$Pair.Evidence %in% c("literature supported","putative"),]
lit <- fantom5[fantom5$Pair.Evidence %in% c("literature supported"),]
# Determine which list of pairs to perform analysis on:
if (include.putative){
ligands <- as.character(lit.put[,2]) #Determines the ligand list to use
recepts <- as.character(lit.put[,4]) #Determines the receptor list to use
modes <- as.character(lit.put[,'mode'])
} else {
ligands <- as.character(lit[,2]) #Determines the ligand list to use
recepts <- as.character(lit[,4]) #Determines the receptor list to use
modes <- as.character(lit[,'mode'])
}
if (include.rejected){
ligands <- as.character(fantom5[,2])
recepts <- as.character(fantom5[,4])
modes <- as.character(fantom5[,'mode'])
}
}
if (LR.database == 'custom'){
if (is.null(custom.list)){stop("\nCustom mapping requested. Please provide custom list of Ligand-Receptor interactions")}
ligands <- as.character(custom.list[,1])
recepts <- as.character(custom.list[,2])
modes <- as.character(custom.list[,3])
}
# Identify ligands and receptors expressed in the object
ligands.use <- intersect(ligands,rownames(object@assays$RNA))
recepts.use <- intersect(recepts,rownames(object@assays$RNA))
genes.use = union(ligands.use,recepts.use)
# Create averages and other relevant cluster-wise metrics, of only these GOI
cluster.avgs <- AverageExpression(object,features = genes.use, assays = 'RNA')$RNA
cluster.avgs.scale <- AverageExpression(object,features = genes.use,slot = "scale.data", assays = 'RNA')$RNA
cluster.pcts <- PercentExpression_v2(object,features = genes.use,slot = 'counts')$RNA #percent cells in cluster expressing greater than zero
if (calculate.DOR){
nodes <- as.character(names(table(Idents(object))))
cluster.DORs <- data.frame(row.names = genes.use)
for (i in 1:length(nodes)){
temp <- DOR(object,ident = nodes[i],features = genes.use)
temp <- data.frame(temp)
colnames(temp) <- nodes[i]
cluster.DORs <- cbind(cluster.DORs,temp)
}
}
# Convert to multiple-row-name format
cluster.avgs.df <- cluster.avgs
cluster.avgs.df$gene <- rownames(cluster.avgs.df)
cluster.avgs.scale.df <- cluster.avgs.scale
cluster.avgs.scale.df$gene <- rownames(cluster.avgs.scale.df)
cluster.pcts.df <- cluster.pcts
PercentExpression_v2 <- function (object, assays = 'RNA', features = NULL, return.seurat = FALSE,
add.ident = NULL, slot = "counts", use.scale = FALSE, use.counts = FALSE,
verbose = TRUE, ...)
{
if (use.scale) {
.Deprecated(msg = "'use.scale' is a deprecated argument, please use the 'slot' argument instead")
slot <- "scale.data"
}
if (use.counts) {
.Deprecated(msg = "'use.counts' is a deprecated argument, please use the 'slot' argument instead")
if (use.scale) {
warning("Both 'use.scale' and 'use.counts' were set; using counts",
call. = FALSE, immediate. = TRUE)
}
slot <- "counts"
}
fxn.average <- function(x) {sum(x>0)/length(x)}
object.assays <- Seurat:::FilterObjects(object = object, classes.keep = "Assay")
# assays <- assays %||% object.assays
ident.orig <- Idents(object = object)
orig.levels <- levels(x = Idents(object = object))
ident.new <- c()
if (!all(assays %in% object.assays)) {
assays <- assays[assays %in% object.assays]
if (length(assays) == 0) {
stop("None of the requested assays are present in the object")
}
else {
warning("Requested assays that do not exist in object. Proceeding with existing assays only.")
}
}
if (!is.null(x = add.ident)) {
new.data <- FetchData(object = object, vars = add.ident)
new.ident <- paste(Idents(object)[rownames(x = new.data)],
new.data[, 1], sep = "_")
Idents(object, cells = rownames(new.data)) <- new.ident
}
data.return <- list()
for (i in 1:length(x = assays)) {
data.use <- GetAssayData(object = object, assay = assays[i],
slot = slot)
features.assay <- features
if (length(x = intersect(x = features, y = rownames(x = data.use))) <
1) {
features.assay <- rownames(x = data.use)
}
data.all <- data.frame(row.names = features.assay)
for (j in levels(x = Idents(object))) {
temp.cells <- WhichCells(object = object, idents = j)
features.assay <- unique(x = intersect(x = features.assay,
y = rownames(x = data.use)))
if (length(x = temp.cells) == 1) {
data.temp <- (data.use[features.assay, temp.cells])
if (slot == "data") {
data.temp <- expm1(x = data.temp)
}
}
if (length(x = temp.cells) > 1) {
data.temp <- apply(X = data.use[features.assay,
temp.cells, drop = FALSE], MARGIN = 1, FUN = fxn.average)
}
data.all <- cbind(data.all, data.temp)
colnames(x = data.all)[ncol(x = data.all)] <- j
if (verbose) {
message(paste("Finished calculating percentage expressing", assays[i],
"for cluster", j))
}
if (i == 1) {
ident.new <- c(ident.new, as.character(x = ident.orig[temp.cells[1]]))
}
}
names(x = ident.new) <- levels(x = Idents(object))
data.return[[i]] <- data.all
names(x = data.return)[i] <- assays[[i]]
}
if (return.seurat) {
toRet <- CreateSeuratObject(counts = data.return[[1]],
project = "Average", assay = names(x = data.return)[1],
...)
if (length(x = data.return) > 1) {
for (i in 2:length(x = data.return)) {
toRet[[names(x = data.return)[i]]] <- CreateAssayObject(counts = data.return[[i]])
}
}
if (DefaultAssay(object = object) %in% names(x = data.return)) {
DefaultAssay(object = toRet) <- DefaultAssay(object = object)
}
Idents(toRet, cells = colnames(x = toRet)) <- ident.new[colnames(x = toRet)]
Idents(object = toRet) <- factor(x = Idents(object = toRet),
levels = as.character(x = orig.levels), ordered = TRUE)
toRet <- NormalizeData(object = toRet, verbose = verbose)
toRet <- ScaleData(object = toRet, verbose = verbose)
return(toRet)
}
else {
return(data.return)
}
}
cluster.pcts.df <- cluster.pcts
cluster.pcts <- PercentExpression_v2(object,features = genes.use,slot = 'counts')$RNA #percent cells in cluster expressing greater than zero
if (calculate.DOR){
nodes <- as.character(names(table(Idents(object))))
cluster.DORs <- data.frame(row.names = genes.use)
for (i in 1:length(nodes)){
temp <- DOR(object,ident = nodes[i],features = genes.use)
temp <- data.frame(temp)
colnames(temp) <- nodes[i]
cluster.DORs <- cbind(cluster.DORs,temp)
}
}
# Convert to multiple-row-name format
cluster.avgs.df <- cluster.avgs
cluster.avgs.df$gene <- rownames(cluster.avgs.df)
cluster.avgs.scale.df <- cluster.avgs.scale
cluster.avgs.scale.df$gene <- rownames(cluster.avgs.scale.df)
cluster.pcts.df <- cluster.pcts
cluster.pcts.df$gene <- rownames(cluster.pcts.df)
if (calculate.DOR){
cluster.DORs.df <- cluster.DORs
cluster.DORs.df$gene <- rownames(cluster.DORs.df)
}
ligands.df <- data.frame(ligands)
ligands.df$id <- 1:nrow(ligands.df)
recepts.df <- data.frame(recepts)
recepts.df$id <- 1:nrow(recepts.df)
ligands.df$ligands == recepts
ligands.df$ligands == recepts.df$recepts
class(ligands.df$ligands)
head(ligands.df)
head(recepts.df)
# Assmeble for later pulling
# Receptor set
cluster.avgs.df.rec <- merge(recepts.df,cluster.avgs.df,by.x = 'recepts',by.y = 'gene',all.x = T)
cluster.avgs.df.rec <- cluster.avgs.df.rec[order(cluster.avgs.df.rec$id),]
cluster.avgs.scale.df.rec <- merge(recepts.df,cluster.avgs.scale.df,by.x = 'recepts',by.y = 'gene',all.x = T)
cluster.avgs.scale.df.rec <- cluster.avgs.scale.df.rec[order(cluster.avgs.scale.df.rec$id),]
cluster.pcts.df.rec <- merge(recepts.df,cluster.pcts.df,by.x = 'recepts',by.y = 'gene',all.x = T)
cluster.pcts.df.rec <- cluster.pcts.df.rec[order(cluster.pcts.df.rec$id),]
if (calculate.DOR){
cluster.DORs.df.rec <- merge(recepts.df,cluster.DORs.df,by.x = 'recepts',by.y = 'gene',all.x = T)
cluster.DORs.df.rec <- cluster.DORs.df.rec[order(cluster.DORs.df.rec$id),]
}
# Ligand set
cluster.avgs.df.lig <- merge(ligands.df,cluster.avgs.df,by.x = 'ligands',by.y = 'gene',all.x = T)
cluster.avgs.df.lig <- cluster.avgs.df.lig[order(cluster.avgs.df.lig$id),]
cluster.avgs.scale.df.lig <- merge(ligands.df,cluster.avgs.scale.df,by.x = 'ligands',by.y = 'gene',all.x = T)
cluster.avgs.scale.df.lig <- cluster.avgs.scale.df.lig[order(cluster.avgs.scale.df.lig$id),]
cluster.pcts.df.lig <- merge(ligands.df,cluster.pcts.df,by.x = 'ligands',by.y = 'gene',all.x = T)
cluster.pcts.df.lig <- cluster.pcts.df.lig[order(cluster.pcts.df.lig$id),]
if (calculate.DOR){
cluster.DORs.df.lig <- merge(ligands.df,cluster.DORs.df,by.x = 'ligands',by.y = 'gene',all.x = T)
cluster.DORs.df.lig <- cluster.DORs.df.lig[order(cluster.DORs.df.lig$id),]
}
# Include Wilcoxon Rank P-values?
if (p.values){
message(paste("\nCalculating p-values using Wilcoxon Rank"))
cluster.p.values <- FindAllMarkers(object,assay = 'RNA',features = genes.use, test.use = 'wilcox',
logfc.threshold = 0,min.pct = 0,return.thresh = Inf)
cluster.p.values$cell.gene <- paste(cluster.p.values$cluster,cluster.p.values$gene,sep = ' - ')
cluster.p.values$gene.cell <- paste(cluster.p.values$gene,cluster.p.values$cluster,sep = ' - ')
}else{}
# Generate full connectome
sources <- colnames(cluster.avgs)
targets <- colnames(cluster.avgs)
message(paste("\nGenerating Connectome"))
pb <- txtProgressBar(min = 0, max = length(sources), initial = 0,style = 3)
connectome <- data.frame()
p.values = F
if (calculate.DOR){
cluster.DORs.df.lig <- merge(ligands.df,cluster.DORs.df,by.x = 'ligands',by.y = 'gene',all.x = T)
cluster.DORs.df.lig <- cluster.DORs.df.lig[order(cluster.DORs.df.lig$id),]
}
# Include Wilcoxon Rank P-values?
if (p.values){
message(paste("\nCalculating p-values using Wilcoxon Rank"))
cluster.p.values <- FindAllMarkers(object,assay = 'RNA',features = genes.use, test.use = 'wilcox',
logfc.threshold = 0,min.pct = 0,return.thresh = Inf)
cluster.p.values$cell.gene <- paste(cluster.p.values$cluster,cluster.p.values$gene,sep = ' - ')
cluster.p.values$gene.cell <- paste(cluster.p.values$gene,cluster.p.values$cluster,sep = ' - ')
}else{}
# Generate full connectome
sources <- colnames(cluster.avgs)
targets <- colnames(cluster.avgs)
message(paste("\nGenerating Connectome"))
pb <- txtProgressBar(min = 0, max = length(sources), initial = 0,style = 3)
connectome <- data.frame()
for (i in 1:length(sources)){
temp <- data.frame()
for (j in 1:length(targets)){
vector <- data.frame(source = sources[i],
target = targets[j],
ligand = ligands,
receptor = recepts,
pair = paste(ligands,recepts,sep = ' - '),
mode = modes,
#ligand.expression = cluster.avgs[ligands,][,sources[i]],
#recept.expression = cluster.avgs[recepts,][,targets[j]],
ligand.expression = cluster.avgs.df.lig[,sources[i]],
recept.expression = cluster.avgs.df.rec[,targets[j]],
#ligand.scale = cluster.avgs.scale[ligands,][,sources[i]],
#recept.scale = cluster.avgs.scale[recepts,][,targets[j]],
ligand.scale = cluster.avgs.scale.df.lig[,sources[i]],
recept.scale = cluster.avgs.scale.df.rec[,targets[j]],
#percent.source = cluster.pcts[ligands,][,sources[i]],
#percent.target = cluster.pcts[recepts,][,targets[j]]
percent.source = cluster.pcts.df.lig[,sources[i]],
percent.target = cluster.pcts.df.rec[,targets[j]]
)
if (calculate.DOR){
#vector$DOR.source = cluster.DORs[ligands,][,sources[i]]
#vector$DOR.target = cluster.DORs[recepts,][,targets[j]]
vector$DOR.source = cluster.DORs.df.lig[,sources[i]]
vector$DOR.target = cluster.DORs.df.rec[,targets[j]]
}
temp <- rbind(temp,vector)
}
connectome <- rbind(connectome,temp)
Sys.sleep(0.5)
setTxtProgressBar(pb,i)
}
View(connectome)
sessionInfo()
CreateConnectome
