#df$weight <- connectome[,weight.attribute]
temp <- connectome[,!colnames(connectome) %in% colnames(df)]
df <- cbind(df,temp)
# Squash ligands back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(df$lig.stash)){
temp <- subset(df,lig.stash == df$lig.stash[i])
if(length(unique(temp$source)) == 1){
df[rownames(temp),]$ligand <- as.character(temp$lig.stash)
}
}
# Squash receptors back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(df$rec.stash)){
temp <- subset(df,rec.stash == df$rec.stash[i])
if(length(unique(temp$target)) == 1){
df[rownames(temp),]$receptor <- as.character(temp$rec.stash)
}
}
# Squash ligands back together, by cell type, if they are expressed on multiple cell types
temp <- subset(df,ligand != lig.stash)
if (nrow(temp)>0){
for (i in 1:length(unique(temp$source))){
temp2 <- subset(temp,source == unique(temp$source)[i])
dummy <- paste(rep('x',i),collapse = '') # Add number of spaces corresponding to number of unique sources
df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
}
}
if (nrow(temp)>0){
for (i in 1:length(unique(temp$source))){
temp2 <- subset(temp,source == unique(temp$source)[i])
dummy <- paste(rep('x',i),collapse = '') # Add number of spaces corresponding to number of unique sources
df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
}
}
# Squash receptors back together, by cell type, if they are expressed on multiple cell types
temp <- subset(df,receptor != rec.stash)
if (nrow(temp)>0){
for (i in 1:length(unique(temp$target))){
temp2 <- subset(temp,target == unique(temp$target)[i])
dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique targets
df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
}
}
#Establish ordering (order) so that genes are grouped nicely by celltype
source.order <- df[order(df$source), ]
target.order <- df[order(df$target), ]
source.order.un <- unique(source.order[,c('ligand','source')])
target.order.un <- unique(target.order[,c('receptor','target')])
source.order$id <- 1:nrow(source.order)
target.order$id <- 1:nrow(target.order)
source.order.un$id <- 1:nrow(source.order.un)
target.order.un$id <- 1:nrow(target.order.un)
sector.order.un <- c(as.character(source.order.un$ligand),
as.character(target.order.un$receptor))
# Coloring setup
if (is.null(cols.use)){
nodes <- as.character(unique(union(df$source,df$target)))
cols.use <- hue_pal()(length(nodes))
names(cols.use) <- nodes
cols.use <- data.frame(cols.use)
cols.use$cell <- rownames(cols.use)
}
sector.order.un
#Set working directory
setwd("~/Box Sync/Kaminski_Lab/Rami U")
# Load required packages
require(connectome)
require(Seurat)
library(readxl)
# Load additional ligand/receptors to be investigated
rami_LR <- read_excel("list of ligands and receptors of interest.xlsx")
# Pull default FANTOM5 database
fantom <- connectome::ncomms8866_human
# Compiled into custom ground-truth list
custom.LR <- data.frame(fantom$Ligand.ApprovedSymbol,fantom$Receptor.ApprovedSymbol,fantom$mode)
colnames(custom.LR) <- c('ligand','receptor','mode')
rami_LR$mode <- 'RAMI'
custom.LR <- rbind(custom.LR,rami_LR) #Looks good
# Load Seurat data
pbmc <- readRDS("~/Box Sync/Kaminski_Lab/Rami U/IPF_Cell_Atlas_noCOPD_Immune_Downsampled_forSAM.srt.Rds")
# Explore distributions
table(pbmc@meta.data$disease.ident,Idents(pbmc)) # Looks good
# Split by identity
split <- SplitObject(pbmc,split.by = 'disease.ident')
# Scale ligand and receptor genes (can also just do all genes)
GOI <- unique(union(custom.LR$ligand,custom.LR$receptor))
for (i in 1:length(split)){
split[[i]] <- ScaleData(split[[i]],features = GOI[(GOI %in% rownames(split[[i]]))])
}
# Make connectomes (for now, without p-values) <-- takes a few minutes per cell type if you want these
split.con <- list()
for (i in 1:length(split)){
split.con[[i]] <- CreateConnectome(split[[i]],species = 'human',LR.database = 'custom',custom.list = custom.LR,p.values = F)
}
# Make differential connectome
diff <- DifferentialConnectome(split.con[[1]],split.con[[2]],min.pct = 0.1) #see the effect of min.pct -- this seems reasonable to me
ggplot(diff,aes(diff$score))+geom_density()
require(ggplot2)
ggplot(diff,aes(diff$score))+geom_density()
# Plot scoring plot
pdf(file = 'PBMC Differential Scoring > 1.pdf',width = 30,height = 10)
DifferentialScoringPlot(diff,min.score = 1)
dev.off()
View(diff)
# RAMI subset
diff.RAMI <- subset(diff,ligand %in% rami_LR$ligand | receptor %in% rami_LR$receptor)
View(diff.RAMI)
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 34,height = 5)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Save differential file
save(diff,file = 'PBMC Differential Connectome.Robj')
# RAMI subset
diff.RAMI <- subset(diff,ligand %in% rami_LR$ligand | receptor %in% rami_LR$receptor)
# Save differential file
save(diff.RAMI,file = 'PBMC Differential Connectome - RAMI Genes.Robj')
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 34,height = 5)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 20,height = 5)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 16,height = 5)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 16,height = 10)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 20,height = 10)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 25,height = 10)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 25,height = 6)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 32,height = 6)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 32,height = 5)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 40,height = 5)
DifferentialScoringPlot(diff.RAMI)
dev.off()
# Plot RAMI interest scores
pdf(file = 'PBMC Differential Scoring RAMI Genes.pdf',width = 40,height = 7)
DifferentialScoringPlot(diff.RAMI)
dev.off()
split
View(diff)
CircosPlot
setwd("~/Documents/GitHub/connectome")
CircosPlot <- function(connectome,
weight.attribute = 'weight_sc',
cols.use = NULL,
min.z = NULL,
lab.cex = 1,
balanced.edges = T,
edge.color.by.source = T,...){
library(tidyverse)
library(circlize)
library(dplyr)
library(scales)
# Perform filtration
if (weight.attribute == 'weight_sc' & is.null(min.z)){
connectome <- FilterConnectome(connectome, remove.na = T,min.z = 0,...)
}else{
connectome <- FilterConnectome(connectome,remove.na = T,min.z = min.z,...)
}
# Pull the dataframe of interest for plotting and format with weight as third column
connectome$lig.stash <- as.character(connectome$ligand)
connectome$rec.stash <- as.character(connectome$receptor)
df <- data.frame(connectome %>% select(ligand,receptor))
df$ligand <- make.unique(as.character(df$ligand))
df$receptor <- make.unique(as.character(df$receptor))
#df$weight <- connectome[,weight.attribute]
temp <- connectome[,!colnames(connectome) %in% colnames(df)]
df <- cbind(df,temp)
# Squash ligands back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(df$lig.stash)){
temp <- subset(df,lig.stash == df$lig.stash[i])
for (i in 1:length(unique(temp$source))){
temp2 <- subset(temp,source == unique(temp$source)[i])
dummy <- paste(rep(' ',i-1),collapse = '') # Add number of spaces corresponding to number of unique sources
df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
}
#if(length(unique(temp$source)) == 1){
#  df[rownames(temp),]$ligand <- as.character(temp$lig.stash)
#}
}
# Squash receptors back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(df$rec.stash)){
temp <- subset(df,rec.stash == df$rec.stash[i])
for (i in 1:length(unique(temp$target))){
temp2 <- subset(temp,target == unique(temp$target)[i])
dummy <- paste(rep(' ',i-1),collapse = '') # Add number of spaces corresponding to number of unique targets
df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
}
#if(length(unique(temp$target)) == 1){
#  df[rownames(temp),]$receptor <- as.character(temp$rec.stash)
#}
}
# Squash ligands back together, by cell type, if they are expressed on multiple cell types
#temp <- subset(df,ligand != lig.stash) # this is a problem
#if (nrow(temp)>0){
#  for (i in 1:length(unique(temp$source))){
#    temp2 <- subset(temp,source == unique(temp$source)[i])
#    dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique sources
#    df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
#  }
#}
# Squash receptors back together, by cell type, if they are expressed on multiple cell types
#temp <- subset(df,receptor != rec.stash) # this is a problem
#if (nrow(temp)>0){
#  for (i in 1:length(unique(temp$target))){
#    temp2 <- subset(temp,target == unique(temp$target)[i])
#    dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique targets
#    df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
#  }
#}
#Establish ordering (order) so that genes are grouped nicely by celltype
source.order <- df[order(df$source), ]
target.order <- df[order(df$target), ]
source.order.un <- unique(source.order[,c('ligand','source')])
target.order.un <- unique(target.order[,c('receptor','target')])
source.order$id <- 1:nrow(source.order)
target.order$id <- 1:nrow(target.order)
source.order.un$id <- 1:nrow(source.order.un)
target.order.un$id <- 1:nrow(target.order.un)
sector.order.un <- c(as.character(source.order.un$ligand),
as.character(target.order.un$receptor))
# Coloring setup
if (is.null(cols.use)){
nodes <- as.character(unique(union(df$source,df$target)))
cols.use <- hue_pal()(length(nodes))
names(cols.use) <- nodes
cols.use <- data.frame(cols.use)
cols.use$cell <- rownames(cols.use)
}
# Map to get ligand colorings (edges)
map <- base::merge(source.order, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.edges <- as.character(map$cols.use)
names(lig.cols.edges) <- map$ligand
# Map to get receptor colorings (edges) # this does not work
map <- base::merge(target.order, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.edges <- as.character(map$cols.use)
names(rec.cols.edges) <- map$receptor
# Map to get ligand colorings (sectors)
map <- base::merge(source.order.un, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.sect <- as.character(map$cols.use)
names(lig.cols.sect) <- map$ligand
# Map to get receptor colorings (sectors)
map <- base::merge(target.order.un, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.sect <- as.character(map$cols.use)
names(rec.cols.sect) <- map$receptor
# Make sector colors (grid.cols)
sectors <- c(source.order.un$ligand,target.order.un$receptor)
sector.cols <- c(as.character(lig.cols.sect),as.character(rec.cols.sect))
# Plotting
# Decide edge order and edge color order
if (edge.color.by.source == T){
edge.color <- lig.cols.edges
df.plot <- source.order
}else{
edge.color <- rec.cols.edges
df.plot <- target.order
}
# Decide weight attributes and balanced vs. not
if (weight.attribute == 'weight_norm'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_norm')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.expression','recept.expression')]
}
}
if (weight.attribute == 'weight_sc'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_sc')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.scale','recept.scale')]
}
}
if (weight.attribute == 'score'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','score')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.norm.lfc','recept.norm.lfc')]
}
}
circos.clear()
chordDiagram(df.plot,
order = sector.order.un,
col = edge.color,
grid.col = sector.cols,
directional = 1,
direction.type = "arrows",
link.arr.type = "big.arrow",annotationTrack = "grid",preAllocateTracks = 1)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
circos.text(mean(xlim), ylim[1] + .01, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),cex = lab.cex)
#circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
}, bg.border = NA)
}
#
CircosPlot(diff,modes.include = 'CCL18',weight.attribute = 'source')
require(dplyr)
#
CircosPlot(diff,modes.include = 'CCL18',weight.attribute = 'source')
#
CircosPlot(diff,features = 'CCL18',weight.attribute = 'source')
#
CircosPlot(diff
,weight.attribute = 'source')
CircosPlot <- function(connectome,
weight.attribute = 'weight_sc',
cols.use = NULL,
min.z = NULL,
lab.cex = 1,
balanced.edges = T,
edge.color.by.source = T,...){
library(tidyverse)
library(circlize)
library(dplyr)
library(scales)
# Perform filtration
if (weight.attribute != 'source'){
if (weight.attribute == 'weight_sc' & is.null(min.z)){
connectome <- FilterConnectome(connectome, remove.na = T,min.z = 0,...)
}else{
connectome <- FilterConnectome(connectome,remove.na = T,min.z = min.z,...)
}
}
# Pull the dataframe of interest for plotting and format with weight as third column
connectome$lig.stash <- as.character(connectome$ligand)
connectome$rec.stash <- as.character(connectome$receptor)
df <- data.frame(connectome %>% select(ligand,receptor))
df$ligand <- make.unique(as.character(df$ligand))
df$receptor <- make.unique(as.character(df$receptor))
#df$weight <- connectome[,weight.attribute]
temp <- connectome[,!colnames(connectome) %in% colnames(df)]
df <- cbind(df,temp)
# Squash ligands back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(df$lig.stash)){
temp <- subset(df,lig.stash == df$lig.stash[i])
for (i in 1:length(unique(temp$source))){
temp2 <- subset(temp,source == unique(temp$source)[i])
dummy <- paste(rep(' ',i-1),collapse = '') # Add number of spaces corresponding to number of unique sources
df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
}
#if(length(unique(temp$source)) == 1){
#  df[rownames(temp),]$ligand <- as.character(temp$lig.stash)
#}
}
# Squash receptors back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(df$rec.stash)){
temp <- subset(df,rec.stash == df$rec.stash[i])
for (i in 1:length(unique(temp$target))){
temp2 <- subset(temp,target == unique(temp$target)[i])
dummy <- paste(rep(' ',i-1),collapse = '') # Add number of spaces corresponding to number of unique targets
df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
}
#if(length(unique(temp$target)) == 1){
#  df[rownames(temp),]$receptor <- as.character(temp$rec.stash)
#}
}
# Squash ligands back together, by cell type, if they are expressed on multiple cell types
#temp <- subset(df,ligand != lig.stash) # this is a problem
#if (nrow(temp)>0){
#  for (i in 1:length(unique(temp$source))){
#    temp2 <- subset(temp,source == unique(temp$source)[i])
#    dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique sources
#    df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
#  }
#}
# Squash receptors back together, by cell type, if they are expressed on multiple cell types
#temp <- subset(df,receptor != rec.stash) # this is a problem
#if (nrow(temp)>0){
#  for (i in 1:length(unique(temp$target))){
#    temp2 <- subset(temp,target == unique(temp$target)[i])
#    dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique targets
#    df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
#  }
#}
#Establish ordering (order) so that genes are grouped nicely by celltype
source.order <- df[order(df$source), ]
target.order <- df[order(df$target), ]
source.order.un <- unique(source.order[,c('ligand','source')])
target.order.un <- unique(target.order[,c('receptor','target')])
source.order$id <- 1:nrow(source.order)
target.order$id <- 1:nrow(target.order)
source.order.un$id <- 1:nrow(source.order.un)
target.order.un$id <- 1:nrow(target.order.un)
sector.order.un <- c(as.character(source.order.un$ligand),
as.character(target.order.un$receptor))
# Coloring setup
if (is.null(cols.use)){
nodes <- as.character(unique(union(df$source,df$target)))
cols.use <- hue_pal()(length(nodes))
names(cols.use) <- nodes
cols.use <- data.frame(cols.use)
cols.use$cell <- rownames(cols.use)
}
# Map to get ligand colorings (edges)
map <- base::merge(source.order, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.edges <- as.character(map$cols.use)
names(lig.cols.edges) <- map$ligand
# Map to get receptor colorings (edges) # this does not work
map <- base::merge(target.order, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.edges <- as.character(map$cols.use)
names(rec.cols.edges) <- map$receptor
# Map to get ligand colorings (sectors)
map <- base::merge(source.order.un, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.sect <- as.character(map$cols.use)
names(lig.cols.sect) <- map$ligand
# Map to get receptor colorings (sectors)
map <- base::merge(target.order.un, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.sect <- as.character(map$cols.use)
names(rec.cols.sect) <- map$receptor
# Make sector colors (grid.cols)
sectors <- c(source.order.un$ligand,target.order.un$receptor)
sector.cols <- c(as.character(lig.cols.sect),as.character(rec.cols.sect))
# Plotting
# Decide edge order and edge color order
if (edge.color.by.source == T){
edge.color <- lig.cols.edges
df.plot <- source.order
}else{
edge.color <- rec.cols.edges
df.plot <- target.order
}
# Decide weight attributes and balanced vs. not
if (weight.attribute == 'weight_norm'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_norm')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.expression','recept.expression')]
}
}
if (weight.attribute == 'weight_sc'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_sc')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.scale','recept.scale')]
}
}
if (weight.attribute == 'score'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','score')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.norm.lfc','recept.norm.lfc')]
}
}
circos.clear()
chordDiagram(df.plot,
order = sector.order.un,
col = edge.color,
grid.col = sector.cols,
directional = 1,
direction.type = "arrows",
link.arr.type = "big.arrow",annotationTrack = "grid",preAllocateTracks = 1)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
circos.text(mean(xlim), ylim[1] + .01, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),cex = lab.cex)
#circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
}, bg.border = NA)
}
#
CircosPlot(diff
,weight.attribute = 'source')
#
CircosPlot(subset(diff,ligand == 'CCL18')
,weight.attribute = 'source')
temp <- subset(diff,ligand == 'CCL18')
CircosPlot(temp,weight.attribute = 'source')
#
temp <- subset(diff, ligand == 'CCL18')
#
temp <- subset(split.con[1], ligand == 'CCL18')
#
temp <- subset(split.con[2], ligand == 'CCL18')
#
temp <- subset(split.con[[2]], ligand == 'CCL18')
CircosPlot(temp)
CircosPlot(temp,weight.attribute = 'weight_norm')
?DifferentialConnectome
split.con[[1]]
View(diff)
View(diff)
