lig.cols.edges <- as.character(map$cols.use)
names(lig.cols.edges) <- map$ligand
# Map to get receptor colorings (edges) # this does not work
map <- base::merge(target.order, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.edges <- as.character(map$cols.use)
names(rec.cols.edges) <- map$receptor
# Map to get ligand colorings (sectors)
map <- base::merge(source.order.un, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.sect <- as.character(map$cols.use)
names(lig.cols.sect) <- map$ligand
# Map to get receptor colorings (sectors)
map <- base::merge(target.order.un, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.sect <- as.character(map$cols.use)
names(rec.cols.sect) <- map$receptor
# Make sector colors (grid.cols)
sectors <- c(source.order.un$ligand,target.order.un$receptor)
sector.cols <- c(as.character(lig.cols.sect),as.character(rec.cols.sect))
# Plotting
# Decide edge order and edge color order
if (edge.color.by.source == T){
edge.color <- lig.cols.edges
df.plot <- source.order
}else{
edge.color <- rec.cols.edges
df.plot <- target.order
}
# Decide weight attributes and balanced vs. not
if (weight.attribute == 'weight_norm'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_norm')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.expression','recept.expression')]
}
}
if (weight.attribute == 'weight_sc'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_sc')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.scale','recept.scale')]
}
}
#if (weight.attribute == 'score'){
#  if (balanced.edges == T){
#    df.plot <- df.plot[,c('ligand','receptor','score')]
#  }else{
#    df.plot <- df.plot[,c('ligand','receptor','ligand.norm.lfc','recept.norm.lfc')]
#  }
#}
circos.clear()
chordDiagram(df.plot,
order = sector.order.un,
col = edge.color,
grid.col = sector.cols,
directional = 1,
direction.type = "arrows",
link.arr.type = "big.arrow",annotationTrack = "grid",preAllocateTracks = 1)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
circos.text(mean(xlim), ylim[1] + .01, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),cex = lab.cex)
#circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
}, bg.border = NA)
# Make and add legend
legend <- Legend(at = as.character(unique(union(df$source,df$target))),
type = "grid",
legend_gp = gpar(fill = as.character(cols.use[as.character(unique(union(df$source,df$target))),]$cols.use)),
title_position = "topleft",
title = "Cell Type")
#draw(legend, x = unit(20, "mm"), y = unit(20, "mm"), just = c("left", "bottom"))
library(gridBase)
plot.new()
circle_size = unit(1, "snpc") # snpc unit gives you a square region
pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size,
just = c("left", "center")))
par(omi = gridOMI(), new = TRUE)
circlize_plot()
upViewport()
draw(lgd_list_vertical, x = circle_size, just = "left")
}
CircosPlot <- function(connectome,
weight.attribute = 'weight_sc',
cols.use = NULL,
min.z = NULL,
lab.cex = 1,
balanced.edges = T,
edge.color.by.source = T,...){
library(tidyverse)
library(circlize)
library(dplyr)
library(scales)
library(ComplexHeatmap)
# If (weight.attribute != 'weight_norm'){
if (weight.attribute == 'weight_sc' & is.null(min.z)){
connectome <- FilterConnectome(connectome, remove.na = T,min.z = 0,...)
}else{
connectome <- FilterConnectome(connectome,remove.na = T,min.z = min.z,...)
}
#}
# Pull the dataframe of interest for plotting and format with weight as third column
connectome$lig.stash <- as.character(connectome$ligand)
connectome$rec.stash <- as.character(connectome$receptor)
df <- data.frame(connectome %>% select(ligand,receptor))
df$ligand <- make.unique(as.character(df$ligand))
df$receptor <- make.unique(as.character(df$receptor))
#df$weight <- connectome[,weight.attribute]
temp <- connectome[,!colnames(connectome) %in% colnames(df)]
df <- cbind(df,temp)
# Squash ligands back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(unique(df$lig.stash))){
temp <- subset(df,lig.stash == unique(df$lig.stash)[i])
for (j in 1:length(unique(temp$source))){
temp2 <- subset(temp,source == unique(temp$source)[j])
dummy <- paste(rep(' ',j-1),collapse = '') # Add number of spaces corresponding to number of unique sources
df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
}
#if(length(unique(temp$source)) == 1){
#  df[rownames(temp),]$ligand <- as.character(temp$lig.stash)
#}
}
# Squash receptors back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(unique(df$rec.stash))){
temp <- subset(df,rec.stash == unique(df$rec.stash)[i])
for (j in 1:length(unique(temp$target))){
temp2 <- subset(temp,target == unique(temp$target)[j])
dummy <- paste(rep(' ',j-1),collapse = '') # Add number of spaces corresponding to number of unique targets
df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
}
#if(length(unique(temp$target)) == 1){
#  df[rownames(temp),]$receptor <- as.character(temp$rec.stash)
#}
}
# Squash ligands back together, by cell type, if they are expressed on multiple cell types
#temp <- subset(df,ligand != lig.stash) # this is a problem
#if (nrow(temp)>0){
#  for (i in 1:length(unique(temp$source))){
#    temp2 <- subset(temp,source == unique(temp$source)[i])
#    dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique sources
#    df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
#  }
#}
# Squash receptors back together, by cell type, if they are expressed on multiple cell types
#temp <- subset(df,receptor != rec.stash) # this is a problem
#if (nrow(temp)>0){
#  for (i in 1:length(unique(temp$target))){
#    temp2 <- subset(temp,target == unique(temp$target)[i])
#    dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique targets
#    df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
#  }
#}
#Establish ordering (order) so that genes are grouped nicely by celltype
source.order <- df[order(df$source), ]
target.order <- df[order(df$target), ]
source.order.un <- unique(source.order[,c('ligand','source')])
target.order.un <- unique(target.order[,c('receptor','target')])
source.order$id <- 1:nrow(source.order)
target.order$id <- 1:nrow(target.order)
source.order.un$id <- 1:nrow(source.order.un)
target.order.un$id <- 1:nrow(target.order.un)
sector.order.un <- c(as.character(source.order.un$ligand),
as.character(target.order.un$receptor))
# Coloring setup
if (is.null(cols.use)){
nodes <- as.character(unique(union(df$source,df$target)))
cols.use <- hue_pal()(length(nodes))
names(cols.use) <- nodes
cols.use <- data.frame(cols.use)
cols.use$cell <- rownames(cols.use)
}else{
cols.use <- data.frame(cols.use)
cols.use$cell <- rownames(cols.use)
}
# Map to get ligand colorings (edges)
map <- base::merge(source.order, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.edges <- as.character(map$cols.use)
names(lig.cols.edges) <- map$ligand
# Map to get receptor colorings (edges) # this does not work
map <- base::merge(target.order, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.edges <- as.character(map$cols.use)
names(rec.cols.edges) <- map$receptor
# Map to get ligand colorings (sectors)
map <- base::merge(source.order.un, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.sect <- as.character(map$cols.use)
names(lig.cols.sect) <- map$ligand
# Map to get receptor colorings (sectors)
map <- base::merge(target.order.un, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.sect <- as.character(map$cols.use)
names(rec.cols.sect) <- map$receptor
# Make sector colors (grid.cols)
sectors <- c(source.order.un$ligand,target.order.un$receptor)
sector.cols <- c(as.character(lig.cols.sect),as.character(rec.cols.sect))
# Plotting
# Decide edge order and edge color order
if (edge.color.by.source == T){
edge.color <- lig.cols.edges
df.plot <- source.order
}else{
edge.color <- rec.cols.edges
df.plot <- target.order
}
# Decide weight attributes and balanced vs. not
if (weight.attribute == 'weight_norm'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_norm')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.expression','recept.expression')]
}
}
if (weight.attribute == 'weight_sc'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_sc')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.scale','recept.scale')]
}
}
#if (weight.attribute == 'score'){
#  if (balanced.edges == T){
#    df.plot <- df.plot[,c('ligand','receptor','score')]
#  }else{
#    df.plot <- df.plot[,c('ligand','receptor','ligand.norm.lfc','recept.norm.lfc')]
#  }
#}
circos.clear()
chordDiagram(df.plot,
order = sector.order.un,
col = edge.color,
grid.col = sector.cols,
directional = 1,
direction.type = "arrows",
link.arr.type = "big.arrow",annotationTrack = "grid",preAllocateTracks = 1)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
circos.text(mean(xlim), ylim[1] + .01, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),cex = lab.cex)
#circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
}, bg.border = NA)
# Make and add legend
legend <- Legend(at = as.character(unique(union(df$source,df$target))),
type = "grid",
legend_gp = gpar(fill = as.character(cols.use[as.character(unique(union(df$source,df$target))),]$cols.use)),
title_position = "topleft",
title = "Cell Type")
#draw(legend, x = unit(20, "mm"), y = unit(20, "mm"), just = c("left", "bottom"))
library(gridBase)
plot.new()
circle_size = unit(1, "snpc") # snpc unit gives you a square region
pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size,
just = c("left", "center")))
par(omi = gridOMI(), new = TRUE)
circlize_plot()
upViewport()
draw(legend, x = circle_size, just = "left")
}
CircosPlot(test,weight.attribute = 'weight_sc',sources.include = cells.of.interest,targets.include = cells.of.interest,lab.cex = 0.4)
require(grid)
CircosPlot(test,weight.attribute = 'weight_sc',sources.include = cells.of.interest,targets.include = cells.of.interest,lab.cex = 0.4)
?gridOMI
gridOMI()
library(gridBase)
gridOMI()
CircosPlot <- function(connectome,
weight.attribute = 'weight_sc',
cols.use = NULL,
min.z = NULL,
lab.cex = 1,
balanced.edges = T,
edge.color.by.source = T,...){
library(tidyverse)
library(circlize)
library(dplyr)
library(scales)
library(ComplexHeatmap)
# If (weight.attribute != 'weight_norm'){
if (weight.attribute == 'weight_sc' & is.null(min.z)){
connectome <- FilterConnectome(connectome, remove.na = T,min.z = 0,...)
}else{
connectome <- FilterConnectome(connectome,remove.na = T,min.z = min.z,...)
}
#}
# Pull the dataframe of interest for plotting and format with weight as third column
connectome$lig.stash <- as.character(connectome$ligand)
connectome$rec.stash <- as.character(connectome$receptor)
df <- data.frame(connectome %>% select(ligand,receptor))
df$ligand <- make.unique(as.character(df$ligand))
df$receptor <- make.unique(as.character(df$receptor))
#df$weight <- connectome[,weight.attribute]
temp <- connectome[,!colnames(connectome) %in% colnames(df)]
df <- cbind(df,temp)
# Squash ligands back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(unique(df$lig.stash))){
temp <- subset(df,lig.stash == unique(df$lig.stash)[i])
for (j in 1:length(unique(temp$source))){
temp2 <- subset(temp,source == unique(temp$source)[j])
dummy <- paste(rep(' ',j-1),collapse = '') # Add number of spaces corresponding to number of unique sources
df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
}
#if(length(unique(temp$source)) == 1){
#  df[rownames(temp),]$ligand <- as.character(temp$lig.stash)
#}
}
# Squash receptors back together to single name if they are duplicates (different edges on same cell type)
for (i in 1:length(unique(df$rec.stash))){
temp <- subset(df,rec.stash == unique(df$rec.stash)[i])
for (j in 1:length(unique(temp$target))){
temp2 <- subset(temp,target == unique(temp$target)[j])
dummy <- paste(rep(' ',j-1),collapse = '') # Add number of spaces corresponding to number of unique targets
df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
}
#if(length(unique(temp$target)) == 1){
#  df[rownames(temp),]$receptor <- as.character(temp$rec.stash)
#}
}
# Squash ligands back together, by cell type, if they are expressed on multiple cell types
#temp <- subset(df,ligand != lig.stash) # this is a problem
#if (nrow(temp)>0){
#  for (i in 1:length(unique(temp$source))){
#    temp2 <- subset(temp,source == unique(temp$source)[i])
#    dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique sources
#    df[rownames(temp2),]$ligand <- paste(as.character(temp2$lig.stash),dummy,sep='')
#  }
#}
# Squash receptors back together, by cell type, if they are expressed on multiple cell types
#temp <- subset(df,receptor != rec.stash) # this is a problem
#if (nrow(temp)>0){
#  for (i in 1:length(unique(temp$target))){
#    temp2 <- subset(temp,target == unique(temp$target)[i])
#    dummy <- paste(rep(' ',i),collapse = '') # Add number of spaces corresponding to number of unique targets
#    df[rownames(temp2),]$receptor <- paste(as.character(temp2$rec.stash),dummy,sep='')
#  }
#}
#Establish ordering (order) so that genes are grouped nicely by celltype
source.order <- df[order(df$source), ]
target.order <- df[order(df$target), ]
source.order.un <- unique(source.order[,c('ligand','source')])
target.order.un <- unique(target.order[,c('receptor','target')])
source.order$id <- 1:nrow(source.order)
target.order$id <- 1:nrow(target.order)
source.order.un$id <- 1:nrow(source.order.un)
target.order.un$id <- 1:nrow(target.order.un)
sector.order.un <- c(as.character(source.order.un$ligand),
as.character(target.order.un$receptor))
# Coloring setup
if (is.null(cols.use)){
nodes <- as.character(unique(union(df$source,df$target)))
cols.use <- hue_pal()(length(nodes))
names(cols.use) <- nodes
cols.use <- data.frame(cols.use)
cols.use$cell <- rownames(cols.use)
}else{
cols.use <- data.frame(cols.use)
cols.use$cell <- rownames(cols.use)
}
# Map to get ligand colorings (edges)
map <- base::merge(source.order, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.edges <- as.character(map$cols.use)
names(lig.cols.edges) <- map$ligand
# Map to get receptor colorings (edges) # this does not work
map <- base::merge(target.order, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.edges <- as.character(map$cols.use)
names(rec.cols.edges) <- map$receptor
# Map to get ligand colorings (sectors)
map <- base::merge(source.order.un, cols.use, by.x = "source", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
lig.cols.sect <- as.character(map$cols.use)
names(lig.cols.sect) <- map$ligand
# Map to get receptor colorings (sectors)
map <- base::merge(target.order.un, cols.use, by.x = "target", by.y = "cell", all = FALSE)
map <- map[order(map$id), ]
rec.cols.sect <- as.character(map$cols.use)
names(rec.cols.sect) <- map$receptor
# Make sector colors (grid.cols)
sectors <- c(source.order.un$ligand,target.order.un$receptor)
sector.cols <- c(as.character(lig.cols.sect),as.character(rec.cols.sect))
# Plotting
# Decide edge order and edge color order
if (edge.color.by.source == T){
edge.color <- lig.cols.edges
df.plot <- source.order
}else{
edge.color <- rec.cols.edges
df.plot <- target.order
}
# Decide weight attributes and balanced vs. not
if (weight.attribute == 'weight_norm'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_norm')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.expression','recept.expression')]
}
}
if (weight.attribute == 'weight_sc'){
if (balanced.edges == T){
df.plot <- df.plot[,c('ligand','receptor','weight_sc')]
}else{
df.plot <- df.plot[,c('ligand','receptor','ligand.scale','recept.scale')]
}
}
#if (weight.attribute == 'score'){
#  if (balanced.edges == T){
#    df.plot <- df.plot[,c('ligand','receptor','score')]
#  }else{
#    df.plot <- df.plot[,c('ligand','receptor','ligand.norm.lfc','recept.norm.lfc')]
#  }
#}
circos.clear()
chordDiagram(df.plot,
order = sector.order.un,
col = edge.color,
grid.col = sector.cols,
directional = 1,
direction.type = "arrows",
link.arr.type = "big.arrow",annotationTrack = "grid",preAllocateTracks = 1)
circos.trackPlotRegion(track.index = 1, panel.fun = function(x, y) {
xlim = get.cell.meta.data("xlim")
ylim = get.cell.meta.data("ylim")
sector.name = get.cell.meta.data("sector.index")
circos.text(mean(xlim), ylim[1] + .01, sector.name, facing = "clockwise", niceFacing = TRUE, adj = c(0, 0.5),cex = lab.cex)
#circos.axis(h = "top", labels.cex = 0.5, major.tick.percentage = 0.2, sector.index = sector.name, track.index = 2)
}, bg.border = NA)
# Make and add legend
legend <- Legend(at = as.character(unique(union(df$source,df$target))),
type = "grid",
legend_gp = gpar(fill = as.character(cols.use[as.character(unique(union(df$source,df$target))),]$cols.use)),
title_position = "topleft",
title = "Cell Type")
#draw(legend, x = unit(20, "mm"), y = unit(20, "mm"), just = c("left", "bottom"))
library(gridBase)
plot.new()
circle_size = unit(1, "snpc") # snpc unit gives you a square region
pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size,
just = c("left", "center")))
par(omi = gridOMI(), new = TRUE)
circlize_plot()
upViewport()
draw(legend, x = circle_size, just = "left")
}
CircosPlot(test,weight.attribute = 'weight_sc',sources.include = cells.of.interest,targets.include = cells.of.interest,lab.cex = 0.4)
?par
gridOMI()
plot.new()
circle_size = unit(1, "snpc")
pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size,
just = c("left", "center")))
par(omi = gridOMI(), new = TRUE)
gridOMI()
?par
?gridOMI
dev.off()
gridOMI()
?circlize_plot
circos.clear()
circle_size = unit(1, "snpc") # snpc unit gives you a square region
pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size,
just = c("left", "center")))
par(omi = gridOMI(), new = TRUE)
gridOMI()
dev.off()
circle_size = unit(1, "snpc") # snpc unit gives you a square region
pushViewport(viewport(x = 0, y = 0.5, width = circle_size, height = circle_size,
just = c("left", "center")))
par(omi = gridOMI(), new = TRUE)
gridOMI()
?unit
?upViewport
?pushViewport
install_github('msraredon/connectome', ref = 'develop',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
CircosPlot(test,weight.attribute = 'weight_sc',sources.include = cells.of.interest,targets.include = cells.of.interest,lab.cex = 0.4)
rm(CircosPlot)
setwd("~/Documents/GitHub/connectome")
document()
install_github('msraredon/connectome', ref = 'develop',auth_token = 'f7ea5d8790fe721ac0c9d5ef115d04068b19ed6d',force = T)
ModalDotPlot(panc8.con2,modes.include = NULL,min.z = NULL,weight.attribute = 'weight_sc')
ModalDotPlot(panc8.con2,modes.include = NULL,min.z = NULL,weight.attribute = 'weight_sc')
ModalDotPlot(panc8.con2,modes.include = NULL,min.z = NULL,weight.attribute = 'weight_sc')
ModalDotPlot(panc8.con2,modes.include = NULL,min.z = NULL,weight.attribute = 'weight_sc')
ModalDotPlot(panc8.con2,modes.include = c('VEGF','WNT','Semaphorins','NOTCH','FGF'),weight.attribute = 'weight_sc',min.z = 0)
CircosPlot(test,sources.include = 'endothelial',lab.cex = 0.4)
CircosPlot(test,sources.include = 'endothelial',lab.cex = 0.4)
CircosPlot(test,sources.include = 'endothelial',lab.cex = 0.8)
CircosPlot(test,sources.include = 'endothelial',lab.cex = 0.8)
CircosPlot(test,sources.include = 'endothelial',lab.cex = 0.8)
p2 <- SignalScatter(panc8.con2, features = c('JAG1','JAG2','DLL4'),label.threshold = 1,weight.attribute = 'weight_sc',min.z = 2)
p2 <- p2 + xlim(2,NA) + ylim(2,NA)
p2
p2 <- SignalScatter(panc8.con2, features = c('JAG1','JAG2','DLL4'),label.threshold = 1,weight.attribute = 'weight_sc',min.z = 2)
p2 <- p2 + xlim(2,NA) + ylim(2,NA)
p2
p2 <- SignalScatter(panc8.con2, features = c('JAG1','JAG2','DLL4'),label.threshold = 1,weight.attribute = 'weight_sc',min.z = 2)
p2 <- p2 + xlim(2,NA) + ylim(2,NA)
p2
p2 <- SignalScatter(panc8.con2, features = c('JAG1','JAG2','DLL4'),label.threshold = 1,weight.attribute = 'weight_sc',min.z = 2)
p2 <- p2 + xlim(2,NA) + ylim(2,NA)
p2
p1 <- CellCellScatter(panc8.con2,sources.include = 'endothelial',targets.include = 'activated_stellate',
label.threshold = 3,
weight.attribute = 'weight_sc',min.pct = 0.25,min.z = 2)
p1 <- p1 + xlim(0,NA) + ylim(0,NA)
p1
ModalDotPlot(panc8.con2,modes.include = c('VEGF','WNT','Semaphorins','NOTCH','FGF'),weight.attribute = 'weight_sc',min.z = 0)
ModalDotPlot(panc8.con2,modes.include = NULL,min.z = NULL,weight.attribute = 'weight_sc')
NetworkPlot(panc8.con2,features = 'VEGFA',min.pct = 0.75,weight.attribute = 'weight_sc')
CircosPlot(test,sources.include = 'endothelial',lab.cex = 0.8)
