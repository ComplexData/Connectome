}
View(connectome)
PercentExpression_v2 <- function (object, assays = 'RNA', features = NULL, return.seurat = FALSE,
add.ident = NULL, slot = "counts", use.scale = FALSE, use.counts = FALSE,
verbose = TRUE, ...)
{
if (use.scale) {
.Deprecated(msg = "'use.scale' is a deprecated argument, please use the 'slot' argument instead")
slot <- "scale.data"
}
if (use.counts) {
.Deprecated(msg = "'use.counts' is a deprecated argument, please use the 'slot' argument instead")
if (use.scale) {
warning("Both 'use.scale' and 'use.counts' were set; using counts",
call. = FALSE, immediate. = TRUE)
}
slot <- "counts"
}
fxn.average <- function(x) {sum(x>0)/length(x)}
object.assays <- Seurat:::FilterObjects(object = object, classes.keep = "Assay")
# assays <- assays %||% object.assays
ident.orig <- Idents(object = object)
orig.levels <- levels(x = Idents(object = object))
ident.new <- c()
if (!all(assays %in% object.assays)) {
assays <- assays[assays %in% object.assays]
if (length(assays) == 0) {
stop("None of the requested assays are present in the object")
}
else {
warning("Requested assays that do not exist in object. Proceeding with existing assays only.")
}
}
if (!is.null(x = add.ident)) {
new.data <- FetchData(object = object, vars = add.ident)
new.ident <- paste(Idents(object)[rownames(x = new.data)],
new.data[, 1], sep = "_")
Idents(object, cells = rownames(new.data)) <- new.ident
}
data.return <- list()
for (i in 1:length(x = assays)) {
data.use <- GetAssayData(object = object, assay = assays[i],
slot = slot)
features.assay <- features
if (length(x = intersect(x = features, y = rownames(x = data.use))) <
1) {
features.assay <- rownames(x = data.use)
}
data.all <- data.frame(row.names = features.assay)
for (j in levels(x = Idents(object))) {
temp.cells <- WhichCells(object = object, idents = j)
features.assay <- unique(x = intersect(x = features.assay,
y = rownames(x = data.use)))
if (length(x = temp.cells) == 1) {
data.temp <- (data.use[features.assay, temp.cells])
if (slot == "data") {
data.temp <- expm1(x = data.temp)
}
}
if (length(x = temp.cells) > 1) {
data.temp <- apply(X = data.use[features.assay,
temp.cells, drop = FALSE], MARGIN = 1, FUN = fxn.average)
}
data.all <- cbind(data.all, data.temp)
colnames(x = data.all)[ncol(x = data.all)] <- j
if (verbose) {
message(paste("Finished calculating percentage expressing", assays[i],
"for cluster", j))
}
if (i == 1) {
ident.new <- c(ident.new, as.character(x = ident.orig[temp.cells[1]]))
}
}
names(x = ident.new) <- levels(x = Idents(object))
data.return[[i]] <- data.all
names(x = data.return)[i] <- assays[[i]]
}
if (return.seurat) {
toRet <- CreateSeuratObject(counts = data.return[[1]],
project = "Average", assay = names(x = data.return)[1],
...)
if (length(x = data.return) > 1) {
for (i in 2:length(x = data.return)) {
toRet[[names(x = data.return)[i]]] <- CreateAssayObject(counts = data.return[[i]])
}
}
if (DefaultAssay(object = object) %in% names(x = data.return)) {
DefaultAssay(object = toRet) <- DefaultAssay(object = object)
}
Idents(toRet, cells = colnames(x = toRet)) <- ident.new[colnames(x = toRet)]
Idents(object = toRet) <- factor(x = Idents(object = toRet),
levels = as.character(x = orig.levels), ordered = TRUE)
toRet <- NormalizeData(object = toRet, verbose = verbose)
toRet <- ScaleData(object = toRet, verbose = verbose)
return(toRet)
}
else {
return(data.return)
}
}
cluster.pcts <- PercentExpression_v2(object,features = genes.use,slot = 'counts')$RNA #percent cells in cluster expressing greater than zero
if (calculate.DOR){
nodes <- as.character(names(table(Idents(object))))
cluster.DORs <- data.frame(row.names = genes.use)
for (i in 1:length(nodes)){
temp <- DOR(object,ident = nodes[i],features = genes.use)
temp <- data.frame(temp)
colnames(temp) <- nodes[i]
cluster.DORs <- cbind(cluster.DORs,temp)
}
}
# Include Wilcoxon Rank P-values?
if (p.values){
message(paste("\nCalculating p-values using Wilcoxon Rank"))
cluster.p.values <- FindAllMarkers(object,assay = 'RNA',features = genes.use, test.use = 'wilcox',
logfc.threshold = 0,min.pct = 0,return.thresh = Inf)
cluster.p.values$cell.gene <- paste(cluster.p.values$cluster,cluster.p.values$gene,sep = ' - ')
cluster.p.values$gene.cell <- paste(cluster.p.values$gene,cluster.p.values$cluster,sep = ' - ')
}else{}
# Generate full connectome
sources <- colnames(cluster.avgs)
targets <- colnames(cluster.avgs)
message(paste("\nGenerating Connectome"))
pb <- txtProgressBar(min = 0, max = length(sources), initial = 0,style = 3)
connectome <- data.frame()
for (i in 1:length(sources)){
temp <- data.frame()
for (j in 1:length(targets)){
vector <- data.frame(source = sources[i],
target = targets[j],
ligand = ligands,
receptor = recepts,
pair = paste(ligands,recepts,sep = ' - '),
mode = modes,
ligand.expression = cluster.avgs[ligands,][,sources[i]],
recept.expression = cluster.avgs[recepts,][,targets[j]],
ligand.scale = cluster.avgs.scale[ligands,][,sources[i]],
recept.scale = cluster.avgs.scale[recepts,][,targets[j]],
percent.source = cluster.pcts[ligands,][,sources[i]],
percent.target = cluster.pcts[recepts,][,targets[j]]
)
if (calculate.DOR){
vector$DOR.source = cluster.DORs[ligands,][,sources[i]]
vector$DOR.target = cluster.DORs[recepts,][,targets[j]]
}
temp <- rbind(temp,vector)
}
connectome <- rbind(connectome,temp)
Sys.sleep(0.5)
setTxtProgressBar(pb,i)
}
# Log transform the expression values (since they were averaged outside of log space)
connectome$ligand.expression <- log1p(connectome$ligand.expression)
connectome$recept.expression <- log1p(connectome$recept.expression)
# Add weights (normalized slot)
if (weight.definition.norm == 'sum'){
connectome$weight_norm<- connectome$ligand.expression + connectome$recept.expression
}else{
if (weight.definition.norm == 'mean'){
connectome$weight_norm<- rowMeans(connectome[c('ligand.expression','recept.expression')])
}else{
if (weight.definition.norm == 'product'){
connectome$weight_norm<- connectome$ligand.expression * connectome$recept.expression
}else{
message(paste("\nNo appropriate parameter specified for weight.definition.norm"))
}
}}
# Add weights (scaled slot)
if (weight.definition.scale == 'sum'){
connectome$weight_sc <- connectome$ligand.scale + connectome$recept.scale
}else{
if (weight.definition.scale == 'mean'){
connectome$weight_sc <- rowMeans(connectome[c('ligand.scale','recept.scale')])
}else{
if (weight.definition.scale == 'product'){
connectome$weight_sc <- connectome$ligand.scale * connectome$recept.scale
}else{
message(paste("\nNo appropriate parameter specified for weight.definition.scale"))
}
}}
#Additional columns
connectome$vector <- paste(connectome$source,connectome$target,sep = ' - ')
connectome$edge <- paste(connectome$source,connectome$ligand,connectome$receptor,connectome$target,sep = ' - ')
connectome$source.ligand <- paste(connectome$source,connectome$ligand,sep = ' - ')
connectome$receptor.target <- paste(connectome$receptor,connectome$target,sep = ' - ')
if(!is.null(species)){connectome$species <- species}
View(connectome)
FeaturePlot(test.object,'Il4')
rownames(test.object)
rownames(test.object)['Il4']
cluster.avgs
cluster.avgs['Il4',]
cluster.avgs['Tlr',]
cluster.avgs['Il4r',]
rownames(cluster.avgs['Il4r',])
rownames(cluster.avgs['Il4',])
class(cluster.avgs)
class(rownames(cluster.avgs))
View(cluster.avgs)
class(cluster.avgs$EC)
class(cluster.avgs$Immune)
rownames(cluster.avgs['Proc',])
cluster.avgs['Ace',]
which(rownames(cluster.avgs) == 'Ace')
which(rownames(cluster.avgs) == 'Il4r')
which(rownames(cluster.avgs) == 'Il4')
which(rownames(cluster.avgs) == 'Proc')
which(rownames(cluster.avgs) == 'Procr')
cluster.avgs['Angptl',]
cluster.avgs['Angptl1',]
cluster.avgs['Angpt',]
cluster.avgs['Angpt1',]
cluster.avgs['Angpt2',]
cluster.avgs['Il4',]
cluster.avgs$gene <- rownames(cluster.avgs)
class(ligands)
ligands
cluster.avgs['Angpt1g',]
cluster.avgs['Angpt1r',]
cluster.avgs['Angpt1',]
cluster.avgs['Adm3',]
cluster.avgs['Adm2',]
cluster.avgs['Adm1',]
cluster.avgs['Adm',]
cluster.avgs['Lep',]
cluster.avgs['Vldl',]
cluster.avgs['SCarb',]
cluster.avgs['Scarb',]
cluster.avgs$Imm
hmp <- c('A2m','Adam9','Adam12')
which(rownames(cluster.avgs) == hmp)
rownames(cluster.avgs)
rownames(cluster.avgs) == hmp
which(rownames(cluster.avgs) == hmp)
?which
sum(rownames(cluster.avgs))
sum(rownames(cluster.avgs)==hmp)
sum(rownames(cluster.avgs)[rownames(cluster.avgs)])
rownames(cluster.avgs)[rownames(cluster.avgs)]
rownames(cluster.avgs)[hmp]
hmp
rownameS(cluster.avgs)
rownames(cluster.avgs)
load("~/Box Sync/Kaminski_Lab/ipf.Robj")
FeaturePlot(ipf,'AGTR2')
FeaturePlot(ipf,'AGTR2',reduction = 'tsne')
FeaturePlot(ipf,'AGTR2',reduction = 'tsne',label = T)
VlnPlot(ipf,'AGTR2',label = T)
load("~/Box Sync/Kaminski_Lab/control.Robj")
VlnPlot(control,'AGTR2',label = T)
VlnPlot(ipf,'AGTR1',label = T)
VlnPlot(control,'AGTR1',label = T)
VlnPlot(ipf,'AGTR1',label = T)
VlnPlot(control,'AGTR1',label = T)
FeaturePlot(ipf,'AGTR1')
FeaturePlot(ipf,'AGTR1',label= T)
FeaturePlot(ipf,'AGTR1',label= T,reduction = 'tsne')
FeaturePlot(control,'AGTR1',label= T,reduction = 'tsne')
setwd("~/Documents/Niklason_Lab/Single_Cell_Analysis")
load("~/Box Sync/Wu Lab/wt.ni.connect.v8.Gen2.Robj")
load("~/Box Sync/Wu Lab/ki.ni.connect.v8.Gen2.Robj")
con.list <- list(wt.ni.connect,ki.ni.connect)
con.list[[1]]$genotype <- 'Wild Type'
con.list[[2]]$genotype <- 'P47 Knock In'
#### FORMAT DATA #### <<____ NOTE, change the log values?? Think carefully here....
# rownames == pair
# colnames == vector
# Value == weight (normalized, not scaled. and not re-logged...  will fix later??)
require(tidyr)
require(cowplot)
meta.list <- list()
data.list <- list()
for (i in 1:length(con.list)){
temp <- con.list[[i]] %>% select(pair,vector,weight)
temp <- subset(temp,weight != 'NA')
test <- spread(data = temp,key = vector,value = weight)
test <- as.matrix(test)
test2 <- test[,-1]
rownames(test2) <- test[,1]
##### FORMAT META DATA #####
meta <- unique(con.list[[i]] %>% select(vector,source,target,genotype))
meta <- as.matrix(meta)
meta2 <- meta[,-1]
rownames(meta2) <- meta[,1]
meta2 <- as.data.frame(meta2)
data.list[[i]] <- test2
meta.list[[i]] <- meta2
}
#### FORMAT DATA #### <<____ NOTE, change the log values?? Think carefully here....
# rownames == pair
# colnames == vector
# Value == weight (normalized, not scaled. and not re-logged...  will fix later??)
require(dplyr)
require(tidyr)
require(cowplot)
meta.list <- list()
data.list <- list()
for (i in 1:length(con.list)){
temp <- con.list[[i]] %>% select(pair,vector,weight)
temp <- subset(temp,weight != 'NA')
test <- spread(data = temp,key = vector,value = weight)
test <- as.matrix(test)
test2 <- test[,-1]
rownames(test2) <- test[,1]
##### FORMAT META DATA #####
meta <- unique(con.list[[i]] %>% select(vector,source,target,genotype))
meta <- as.matrix(meta)
meta2 <- meta[,-1]
rownames(meta2) <- meta[,1]
meta2 <- as.data.frame(meta2)
data.list[[i]] <- test2
meta.list[[i]] <- meta2
}
### MAKE Seurat object ####
seurat.list <- list()
for (i in 1:length(data.list)){
seurat.list[[i]] <- CreateSeuratObject(data.list[[i]],assay = 'LR',meta.data = meta.list[[i]])
}
require(Seurat)
### MAKE Seurat object ####
seurat.list <- list()
for (i in 1:length(data.list)){
seurat.list[[i]] <- CreateSeuratObject(data.list[[i]],assay = 'LR',meta.data = meta.list[[i]])
}
lr.merge <- merge(seurat.list[[1]],seurat.list[[2]])
lr.merge  <- NormalizeData(lr.merge)
lr.merge  <- ScaleData(lr.merge)
lr.merge <- FindVariableFeatures(lr.merge)
lr.merge <- RunPCA(lr.merge)
ElbowPlot(lr.merge,ndims = 50)
lr.merge <- FindNeighbors(lr.merge,force.recalc = T)
lr.merge <- FindClusters(lr.merge,resolution = 0.4)
lr.merge <- RunTSNE(lr.merge,dims = 1:50)
lr.merge <- RunUMAP(lr.merge, dims = 1:50)
DimPlot(lr.merge,reduction = 'umap')
DimPlot(lr.merge,reduction = 'tsne')
p1 <- DimPlot(lr.merge,reduction = 'umap',label = T) + NoLegend()
p2 <- DimPlot(lr.merge,reduction = 'umap',group.by = 'genotype')
plot_grid(p1,p2)
pdf(file = 'Wild Type vs. P47 Knock-In ConnectomicTSNE.pdf')
plot_grid(p1,p2)
dev.off()
lr.m.sub <- subset(lr.merge,idents = c('12'))
p1 <- DimPlot(lr.m.sub,reduction = 'umap',label = T) + NoLegend()
p2 <- DimPlot(lr.m.sub,reduction = 'umap',group.by = 'genotype')
p3 <- DimPlot(lr.m.sub,reduction = 'umap',group.by = 'source')
p4 <- DimPlot(lr.m.sub,reduction = 'umap',group.by = 'target')
plot_grid(p1,p2,p3,p4)
pdf(file = "IDENT 12 - Wild Type vs. P47 Knock-In ConnectomicTSNE.pdf")
plot_grid(p1,p2,p3,p4)
dev.off()
# Find Markers
mark.12 <- FindMarkers(lr.merge,ident.1 = '12')
pdf(file = "IDENT 12 - Wild Type vs. P47 Knock-In ConnectomicTSNE.pdf",width = 20,height =20)
plot_grid(p1,p2,p3,p4)
dev.off()
pdf(file = "IDENT 12 - Wild Type vs. P47 Knock-In ConnectomicTSNE.pdf",width = 10,height =10)
plot_grid(p1,p2,p3,p4)
dev.off()
pdf(file = "IDENT 12 - Wild Type vs. P47 Knock-In ConnectomicTSNE.pdf",width = 15,height =10)
plot_grid(p1,p2,p3,p4)
dev.off()
View(mark.12)
load("~/Box Sync/BEF/Lung Data/BEF14/scRNAseq/BEF14.Robj")
load("~/Box Sync/BEF/Lung Data/BEF15/scRNAseq/BEF15.Robj")
load("~/Box Sync/BEF/Native Reference Object/high.res.adult.rat.2-28-2020.Robj")
require(Seurat)
BEF14 <- ScaleData(BEF14,features = rownames(BEF14))
BEF15 <- ScaleData(BEF15,features = rownames(BEF15))
high.res.adult.rat <- ScaleData(high.res.adult.rat,features = rownames(high.res.adult.rat))
table(Idents(BEF14))
require(connectome)
?CreateConnectome
BEF14.con <- CreateConnectome(BEF14,species = 'rat',p.values = F,calculate.DOR = F)
View(BEF14.con)
BEF14.con2 <- FilterConnectome(BEF14.con,min.pct = 0.1,min.z = 0.25,remove.na = T)
View(BEF14.con2)
NetworkPlot(BEF14.con,'Vegfa',min.pct = 0.2,weight.attribute = 'weight_norm')
NetworkPlot(BEF14.con,'Wnt3a',min.pct = 0.2,weight.attribute = 'weight_norm')
test <- FilterConnectome(BEF14.con,min.z = 0,min.pct = 0.1,modes.include = 'TGFB')
test <- data.frame(test %>% group_by(vector) %>% top_n(5,weight_norm))
CircosPlot(test,weight.attribute = 'weight_norm',lab.cex = 1)
ModalDotPlot(BEF14.con,modes.include = NULL,min.z = NULL,weight.attribute = 'weight_norm')
ModalDotPlot(BEF14.con,modes.include = c('VEGF','WNT','Semaphorins','NOTCH','FGF'),
weight.attribute = 'weight_norm')
test1 <- FilterConnectome(BEF14.con,min.z = 0,min.pct = 0.1,modes.include = 'NOTCH')
CircosPlot(test1,weight.attribute = 'weight_norm',balanced.edges = F)
sessionInfo()
setwd("~/Documents/GitHub/connectome")
setwd("~/Documents/GitHub/connectome/vignettes")
For the purposes of demonstration, we will will run the Connectome workflow on the PBMC dataset often used for demonstrations in Seurat:
```
require(Seurat)
require(connectome)
# Load the PBMC dataset
pbmc.data <- Read10X(data.dir = "../data/pbmc3k/filtered_gene_bc_matrices/hg19/")
# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc
```
pbmc.data <- Read10X(data.dir = "../data/pbmc3k/filtered_gene_bc_matrices/hg19/")
?InstallData
require(Seurat)
?InstallData
load("~/Box Sync/Science Response/Base objects for computational work (Use Human GEN2 for revision work)/objects/rat_cca 2018-08-04 .Robj")
unlink('Connectome Workflow_cache', recursive = TRUE)
load("~/Documents/GitHub/connectome/data/rat_cca 2018-08-04 .Robj")
Read10X(data.dir = "../data/pbmc3k/filtered_gene_bc_matrices/hg19/")
library(dplyr)
library(Seurat)
library(patchwork)
# Load the PBMC dataset
pbmc.data <- Read10X(data.dir = "../data/pbmc3k/filtered_gene_bc_matrices/hg19/")
# Initialize the Seurat object with the raw (non-normalized data).
pbmc <- CreateSeuratObject(counts = pbmc.data, project = "pbmc3k", min.cells = 3, min.features = 200)
pbmc
library(SeuratData)
??InstallData
InstallData("panc8")
data("panc8")
InstallData('pbmc')
InstallData("ifnb")
?data
For the purposes of demonstration, we will will run the Connectome workflow on the rat lung data from Raredon et al. 2019:
```
library(Seurat)
library(SeuratData)
library(connectome)
# Load rat lung dataset
data('ifnb',package = Seurat)
# Update to a Seurat 3.0 Object
rat <- UpdateSeuratObject(rat_cca)
rat
```
data('ifnb',package = Seurat)
data('ifnb',package = 'Seurat')
data('ifnb',package = 'SeuratData')
library(SeuratData)
data('ifnb')
unlink('Connectome Workflow_cache', recursive = TRUE)
data("ifnb")
ifnb.list <- SplitObject(ifnb, split.by = "stim")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(Seurat)
library(SeuratData)
InstallData("pbmc3k")
data("pbmc3k")
pbmc3k
?CreateConnectome
unlink('Connectome Workflow_cache', recursive = TRUE)
library(Seurat)
library(SeuratData)
InstallData("pbmc3k")
data("pbmc3k")
pbmc3k
data("pbmc3k")
data("pbmc3k",package = 'SeuratData')
data("pbmc3k")
unlink('Connectome Workflow_cache', recursive = TRUE)
library(Seurat)
library(SeuratData)
InstallData("pbmc3k")
data("pbmc3k")
pbmc3k
InstallData("pbmc3k")
library(SeuratData)
data("pbmc3k")
library(SeuratData)
download.file(url = "http://ismayc.github.io/periodic-table-data.csv",
destfile = "periodic-table-data.csv")
download.file(url = "http://ismayc.github.io/periodic-table-data.csv",
destfile = "periodic-table-data.csv")
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(SeuratData)
library(SeuratData)
data('panc8')
library(SeuratData)
data('pbmc3k')
library(SeuratData)
data('pbmc3k')
library(SeuratData)
data('panc8')
knitr::opts_chunk$set(
collapse = TRUE,
comment = "#>"
)
library(SeuratData)
data('pbmc3k')
pbmc3k
pbmc <- pbmc3k
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
pbmc <- NormalizeData(pbmc)
pbmc <- FindVariableFeatures(pbmc)
pbmc <- ScaleData(pbmc, features = all.genes)
pbmc <- pbmc3k
pbmc[["percent.mt"]] <- PercentageFeatureSet(pbmc, pattern = "^MT-")
pbmc <- subset(pbmc, subset = nFeature_RNA > 200 & nFeature_RNA < 2500 & percent.mt < 5)
pbmc <- NormalizeData(pbmc)
pbmc <- FindVariableFeatures(pbmc)
pbmc <- ScaleData(pbmc, features = rownames(pbmc))
pbmc <- RunPCA(pbmc, features = VariableFeatures(object = pbmc))
pbmc <- FindNeighbors(pbmc, dims = 1:10)
pbmc <- FindClusters(pbmc, resolution = 0.5)
pbmc <- RunUMAP(pbmc, dims = 1:10)
DimPlot(pbmc, reduction = "umap")
